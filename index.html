<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NeuroMono - Intelligent Stereo to Mono Audio Conversion</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #e0e0e0;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 40px;
    }

    header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    header p {
      color: #a0a0a0;
      font-size: 1.1rem;
    }

    .card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 24px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .card h2 {
      font-size: 1.3rem;
      margin-bottom: 16px;
      color: #667eea;
    }

    .upload-area {
      border: 2px dashed rgba(102, 126, 234, 0.5);
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
    }

    .upload-area:hover {
      border-color: #667eea;
      background: rgba(102, 126, 234, 0.1);
    }

    .upload-area.dragover {
      border-color: #764ba2;
      background: rgba(118, 75, 162, 0.2);
    }

    .upload-area p {
      margin-bottom: 12px;
    }

    .upload-area .icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    input[type="file"] {
      display: none;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
    }

    .control-group {
      background: rgba(0, 0, 0, 0.2);
      padding: 16px;
      border-radius: 8px;
    }

    .control-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #b0b0b0;
    }

    .control-group input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
    }

    .control-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      cursor: pointer;
      transition: transform 0.2s;
    }

    .control-group input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    .value-display {
      text-align: right;
      color: #667eea;
      font-weight: 600;
      margin-top: 4px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
    }

    .checkbox-group input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: #667eea;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .button-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .analysis-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
    }

    .analysis-item {
      background: rgba(0, 0, 0, 0.2);
      padding: 16px;
      border-radius: 8px;
      text-align: center;
    }

    .analysis-item .label {
      font-size: 0.85rem;
      color: #a0a0a0;
      margin-bottom: 8px;
    }

    .analysis-item .value {
      font-size: 1.5rem;
      font-weight: 700;
      color: #667eea;
    }

    .frequency-bars {
      display: flex;
      gap: 4px;
      height: 60px;
      align-items: flex-end;
      justify-content: center;
      margin-top: 12px;
    }

    .freq-bar {
      width: 40px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 4px 4px 0 0;
      transition: height 0.3s;
      position: relative;
    }

    .freq-bar span {
      position: absolute;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.75rem;
      color: #a0a0a0;
    }

    canvas {
      width: 100%;
      height: 150px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      margin-bottom: 12px;
    }

    .waveform-container {
      margin-bottom: 20px;
    }

    .waveform-container h3 {
      margin-bottom: 8px;
      font-size: 1rem;
      color: #b0b0b0;
    }

    .status-message {
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 16px;
      display: none;
    }

    .status-message.success {
      background: rgba(34, 197, 94, 0.2);
      border: 1px solid rgba(34, 197, 94, 0.4);
      color: #22c55e;
      display: block;
    }

    .status-message.error {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.4);
      color: #ef4444;
      display: block;
    }

    .status-message.info {
      background: rgba(59, 130, 246, 0.2);
      border: 1px solid rgba(59, 130, 246, 0.4);
      color: #3b82f6;
      display: block;
    }

    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .hidden {
      display: none !important;
    }

    .presets {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }

    .preset-btn {
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #b0b0b0;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.9rem;
    }

    .preset-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: #667eea;
      color: white;
    }

    @media (max-width: 768px) {
      header h1 {
        font-size: 1.8rem;
      }

      .card {
        padding: 16px;
      }

      .controls-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üéµ NeuroMono</h1>
      <p>Intelligent Stereo to Mono Audio Conversion Demo</p>
    </header>

    <!-- Upload Section -->
    <div class="card">
      <h2>üìÅ Upload Audio File</h2>
      <div class="upload-area" id="uploadArea">
        <div class="icon">üéß</div>
        <p><strong>Click to upload</strong> or drag and drop</p>
        <p style="color: #a0a0a0; font-size: 0.9rem;">Supports MP3, WAV, OGG, FLAC (stereo files only)</p>
        <input type="file" id="fileInput" accept="audio/*">
      </div>
      <div id="fileInfo" class="status-message success hidden"></div>
    </div>

    <!-- Controls Section -->
    <div class="card" id="controlsCard">
      <h2>‚öôÔ∏è Conversion Settings</h2>
      
      <div class="presets">
        <button class="preset-btn" data-preset="voice">üé§ Voice/Podcast</button>
        <button class="preset-btn" data-preset="music">üéµ Music</button>
        <button class="preset-btn" data-preset="fast">‚ö° Fast</button>
        <button class="preset-btn" data-preset="balanced">‚öñÔ∏è Balanced</button>
        <button class="preset-btn" data-preset="maximum">üîù Maximum</button>
      </div>

      <div class="controls-grid">
        <div class="control-group">
          <label for="widthSlider">Stereo Width Preservation</label>
          <input type="range" id="widthSlider" min="0" max="100" value="70">
          <div class="value-display" id="widthValue">0.70</div>
        </div>

        <div class="control-group">
          <label for="richnessSlider">Richness Preservation</label>
          <input type="range" id="richnessSlider" min="0" max="100" value="80">
          <div class="value-display" id="richnessValue">0.80</div>
        </div>

        <div class="control-group">
          <label for="volumeSlider">Volume Compensation</label>
          <input type="range" id="volumeSlider" min="50" max="200" value="110">
          <div class="value-display" id="volumeValue">1.10x</div>
        </div>

        <div class="control-group">
          <label for="qualitySlider">Quality Level</label>
          <input type="range" id="qualitySlider" min="0" max="100" value="80">
          <div class="value-display" id="qualityValue">0.80</div>
        </div>

        <div class="control-group">
          <label class="checkbox-group">
            <input type="checkbox" id="spectralCheck" checked>
            <span>Enable Spectral Analysis</span>
          </label>
        </div>
      </div>

      <div class="button-group" style="margin-top: 20px;">
        <button class="btn btn-primary" id="analyzeBtn" disabled>
          üîç Analyze
        </button>
        <button class="btn btn-primary" id="convertBtn" disabled>
          üîÑ Convert to Mono
        </button>
      </div>
    </div>

    <!-- Analysis Section -->
    <div class="card hidden" id="analysisCard">
      <h2>üìä Stereo Analysis</h2>
      <div class="analysis-grid">
        <div class="analysis-item">
          <div class="label">Stereo Width</div>
          <div class="value" id="widthResult">--</div>
        </div>
        <div class="analysis-item">
          <div class="label">Spectral Richness</div>
          <div class="value" id="richnessResult">--</div>
        </div>
        <div class="analysis-item">
          <div class="label">RMS Level</div>
          <div class="value" id="rmsResult">--</div>
        </div>
        <div class="analysis-item">
          <div class="label">Peak Level</div>
          <div class="value" id="peakResult">--</div>
        </div>
        <div class="analysis-item">
          <div class="label">Phase Correlation</div>
          <div class="value" id="phaseResult">--</div>
        </div>
      </div>
      <div style="margin-top: 24px; text-align: center;">
        <div class="label">Frequency Distribution</div>
        <div class="frequency-bars">
          <div class="freq-bar" id="lowBar" style="height: 0%;">
            <span>Low</span>
          </div>
          <div class="freq-bar" id="midBar" style="height: 0%;">
            <span>Mid</span>
          </div>
          <div class="freq-bar" id="highBar" style="height: 0%;">
            <span>High</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Waveform Section -->
    <div class="card hidden" id="waveformCard">
      <h2>üìà Waveform Visualization</h2>
      
      <div class="waveform-container">
        <h3>Original Stereo</h3>
        <canvas id="originalWaveform"></canvas>
        <div class="button-group">
          <button class="btn btn-secondary" id="playOriginalBtn" disabled>
            ‚ñ∂Ô∏è Play Original
          </button>
          <button class="btn btn-secondary" id="stopOriginalBtn" disabled>
            ‚èπÔ∏è Stop
          </button>
        </div>
      </div>

      <div class="waveform-container">
        <h3>Converted Mono</h3>
        <canvas id="monoWaveform"></canvas>
        <div class="button-group">
          <button class="btn btn-secondary" id="playMonoBtn" disabled>
            ‚ñ∂Ô∏è Play Mono
          </button>
          <button class="btn btn-secondary" id="stopMonoBtn" disabled>
            ‚èπÔ∏è Stop
          </button>
          <button class="btn btn-secondary" id="downloadBtn" disabled>
            üíæ Download
          </button>
        </div>
      </div>
    </div>

    <!-- Status -->
    <div id="statusMessage" class="status-message"></div>
  </div>

  <script src="dist/index.browser.js"></script>
  <script>
    // Global state
    let audioContext = null;
    let originalBuffer = null;
    let monoBuffer = null;
    let originalSource = null;
    let monoSource = null;
    let analyser = null;

    // DOM Elements
    const uploadArea = document.getElementById('uploadArea');
    const fileInput = document.getElementById('fileInput');
    const fileInfo = document.getElementById('fileInfo');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const convertBtn = document.getElementById('convertBtn');
    const playOriginalBtn = document.getElementById('playOriginalBtn');
    const playMonoBtn = document.getElementById('playMonoBtn');
    const stopOriginalBtn = document.getElementById('stopOriginalBtn');
    const stopMonoBtn = document.getElementById('stopMonoBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusMessage = document.getElementById('statusMessage');
    const analysisCard = document.getElementById('analysisCard');
    const waveformCard = document.getElementById('waveformCard');

    // Sliders
    const widthSlider = document.getElementById('widthSlider');
    const richnessSlider = document.getElementById('richnessSlider');
    const volumeSlider = document.getElementById('volumeSlider');
    const qualitySlider = document.getElementById('qualitySlider');
    const spectralCheck = document.getElementById('spectralCheck');

    // Value displays
    const widthValue = document.getElementById('widthValue');
    const richnessValue = document.getElementById('richnessValue');
    const volumeValue = document.getElementById('volumeValue');
    const qualityValue = document.getElementById('qualityValue');

    // Presets
    const presets = {
      voice: { width: 30, richness: 60, volume: 120, quality: 70, spectral: true },
      music: { width: 90, richness: 95, volume: 110, quality: 100, spectral: true },
      fast: { width: 50, richness: 50, volume: 110, quality: 50, spectral: false },
      balanced: { width: 70, richness: 75, volume: 110, quality: 75, spectral: true },
      maximum: { width: 100, richness: 100, volume: 120, quality: 100, spectral: true }
    };

    // Initialize Audio Context
    function initAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioContext;
    }

    // Show status message
    function showStatus(message, type = 'info') {
      statusMessage.textContent = message;
      statusMessage.className = `status-message ${type}`;
      statusMessage.style.display = 'block';
      
      if (type === 'success' || type === 'info') {
        setTimeout(() => {
          statusMessage.style.display = 'none';
        }, 3000);
      }
    }

    // Update slider displays
    function updateSliderDisplays() {
      widthValue.textContent = (widthSlider.value / 100).toFixed(2);
      richnessValue.textContent = (richnessSlider.value / 100).toFixed(2);
      volumeValue.textContent = (volumeSlider.value / 100).toFixed(2) + 'x';
      qualityValue.textContent = (qualitySlider.value / 100).toFixed(2);
    }

    // Apply preset
    function applyPreset(preset) {
      const settings = presets[preset];
      if (!settings) return;

      widthSlider.value = settings.width;
      richnessSlider.value = settings.richness;
      volumeSlider.value = settings.volume;
      qualitySlider.value = settings.quality;
      spectralCheck.checked = settings.spectral;

      updateSliderDisplays();
      showStatus(`Applied ${preset} preset`, 'success');
    }

    // File upload handling
    uploadArea.addEventListener('click', () => fileInput.click());
    uploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadArea.classList.add('dragover');
    });
    uploadArea.addEventListener('dragleave', () => {
      uploadArea.classList.remove('dragover');
    });
    uploadArea.addEventListener('drop', async (e) => {
      e.preventDefault();
      uploadArea.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file) await loadAudioFile(file);
    });
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) await loadAudioFile(file);
    });

    // Load audio file
    async function loadAudioFile(file) {
      if (!file.type.startsWith('audio/')) {
        showStatus('Please upload an audio file', 'error');
        return;
      }

      try {
        initAudioContext();
        const arrayBuffer = await file.arrayBuffer();
        originalBuffer = await audioContext.decodeAudioData(arrayBuffer);

        if (originalBuffer.numberOfChannels < 2) {
          showStatus('Please upload a stereo audio file (2+ channels)', 'error');
          return;
        }

        fileInfo.textContent = `‚úÖ Loaded: ${file.name} (${originalBuffer.duration.toFixed(2)}s, ${originalBuffer.sampleRate}Hz, ${originalBuffer.numberOfChannels} channels)`;
        fileInfo.classList.remove('hidden');
        analyzeBtn.disabled = false;
        convertBtn.disabled = false;

        drawWaveform('originalWaveform', originalBuffer);
        playOriginalBtn.disabled = false;
        stopOriginalBtn.disabled = false;

        showStatus('Audio file loaded successfully!', 'success');
      } catch (error) {
        console.error('Error loading audio:', error);
        showStatus('Error loading audio file', 'error');
      }
    }

    // Analyze stereo audio
    analyzeBtn.addEventListener('click', () => {
      if (!originalBuffer) return;

      try {
        const left = originalBuffer.getChannelData(0);
        const right = originalBuffer.getChannelData(1);

        const stereoBuffer = {
          left: new Float32Array(left),
          right: new Float32Array(right),
          sampleRate: originalBuffer.sampleRate
        };

        const analysis = window.NeuroMono.analyze(stereoBuffer);

        document.getElementById('widthResult').textContent = (analysis.width * 100).toFixed(1) + '%';
        document.getElementById('richnessResult').textContent = (analysis.richness * 100).toFixed(1) + '%';
        document.getElementById('rmsResult').textContent = analysis.rmsLevel.toFixed(4);
        document.getElementById('peakResult').textContent = analysis.peakLevel.toFixed(4);
        document.getElementById('phaseResult').textContent = analysis.phaseCorrelation.toFixed(4);

        // Update frequency bars
        document.getElementById('lowBar').style.height = (analysis.frequencyDistribution.low * 100) + '%';
        document.getElementById('midBar').style.height = (analysis.frequencyDistribution.mid * 100) + '%';
        document.getElementById('highBar').style.height = (analysis.frequencyDistribution.high * 100) + '%';

        analysisCard.classList.remove('hidden');
        showStatus('Analysis complete!', 'success');
      } catch (error) {
        console.error('Analysis error:', error);
        showStatus('Error analyzing audio', 'error');
      }
    });

    // Convert to mono
    convertBtn.addEventListener('click', () => {
      if (!originalBuffer) return;

      convertBtn.innerHTML = '<span class="loading"></span> Converting...';
      convertBtn.disabled = true;

      setTimeout(() => {
        try {
          const left = originalBuffer.getChannelData(0);
          const right = originalBuffer.getChannelData(1);

          const stereoBuffer = {
            left: new Float32Array(left),
            right: new Float32Array(right),
            sampleRate: originalBuffer.sampleRate
          };

          const converter = window.NeuroMono.createConverter()
            .preserveWidth(widthSlider.value / 100)
            .preserveRichness(richnessSlider.value / 100)
            .volumeCompensation(volumeSlider.value / 100)
            .quality(qualitySlider.value / 100)
            .spectralAnalysis(spectralCheck.checked);

          const monoData = converter.convert(stereoBuffer);

          // Create mono AudioBuffer
          monoBuffer = audioContext.createBuffer(1, monoData.length, originalBuffer.sampleRate);
          monoBuffer.copyToChannel(monoData, 0);

          drawWaveform('monoWaveform', monoBuffer);
          waveformCard.classList.remove('hidden');
          playMonoBtn.disabled = false;
          stopMonoBtn.disabled = false;
          downloadBtn.disabled = false;

          showStatus('Conversion complete!', 'success');
        } catch (error) {
          console.error('Conversion error:', error);
          showStatus('Error converting audio: ' + error.message, 'error');
        } finally {
          convertBtn.innerHTML = 'üîÑ Convert to Mono';
          convertBtn.disabled = false;
        }
      }, 100);
    });

    // Draw waveform
    function drawWaveform(canvasId, buffer) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');
      
      canvas.width = canvas.offsetWidth * 2;
      canvas.height = canvas.offsetHeight * 2;

      const width = canvas.width;
      const height = canvas.height;
      const centerY = height / 2;

      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(0, 0, width, height);

      const channelCount = Math.min(buffer.numberOfChannels, 2);
      const samples = buffer.length;
      const step = Math.ceil(samples / width);

      for (let ch = 0; ch < channelCount; ch++) {
        const data = buffer.getChannelData(ch);
        const channelHeight = height / channelCount;
        const channelCenterY = ch * channelHeight + channelHeight / 2;

        ctx.strokeStyle = ch === 0 ? '#667eea' : '#764ba2';
        ctx.lineWidth = 2;
        ctx.beginPath();

        for (let x = 0; x < width; x++) {
          let min = 1.0;
          let max = -1.0;

          for (let i = 0; i < step; i++) {
            const datum = data[x * step + i];
            if (datum < min) min = datum;
            if (datum > max) max = datum;
          }

          ctx.moveTo(x, channelCenterY + min * channelHeight * 0.45);
          ctx.lineTo(x, channelCenterY + max * channelHeight * 0.45);
        }

        ctx.stroke();
      }
    }

    // Play original
    playOriginalBtn.addEventListener('click', () => {
      stopAudio();
      originalSource = audioContext.createBufferSource();
      originalSource.buffer = originalBuffer;
      originalSource.connect(audioContext.destination);
      originalSource.start();
    });

    // Play mono
    playMonoBtn.addEventListener('click', () => {
      stopAudio();
      monoSource = audioContext.createBufferSource();
      monoSource.buffer = monoBuffer;
      monoSource.connect(audioContext.destination);
      monoSource.start();
    });

    // Stop audio
    function stopAudio() {
      if (originalSource) {
        try { originalSource.stop(); } catch (e) {}
        originalSource = null;
      }
      if (monoSource) {
        try { monoSource.stop(); } catch (e) {}
        monoSource = null;
      }
    }

    stopOriginalBtn.addEventListener('click', stopAudio);
    stopMonoBtn.addEventListener('click', stopAudio);

    // Download converted audio
    downloadBtn.addEventListener('click', async () => {
      if (!monoBuffer) return;

      downloadBtn.textContent = '‚è≥ Encoding...';
      downloadBtn.disabled = true;

      try {
        const offlineContext = new OfflineAudioContext(
          1,
          monoBuffer.length,
          monoBuffer.sampleRate
        );

        const source = offlineContext.createBufferSource();
        source.buffer = monoBuffer;
        source.connect(offlineContext.destination);
        source.start();

        const renderedBuffer = await offlineContext.startRendering();

        // Convert to WAV
        const wav = audioBufferToWav(renderedBuffer);
        const blob = new Blob([wav], { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'converted_mono.wav';
        a.click();

        URL.revokeObjectURL(url);
        showStatus('Download started!', 'success');
      } catch (error) {
        console.error('Download error:', error);
        showStatus('Error creating download', 'error');
      } finally {
        downloadBtn.textContent = 'üíæ Download';
        downloadBtn.disabled = false;
      }
    });

    // Convert AudioBuffer to WAV format
    function audioBufferToWav(buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const format = 1; // PCM
      const bitDepth = 16;

      const bytesPerSample = bitDepth / 8;
      const blockAlign = numChannels * bytesPerSample;

      const dataLength = buffer.length * blockAlign;
      const bufferLength = 44 + dataLength;

      const arrayBuffer = new ArrayBuffer(bufferLength);
      const view = new DataView(arrayBuffer);

      // WAV header
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataLength, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, format, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitDepth, true);
      writeString(view, 36, 'data');
      view.setUint32(40, dataLength, true);

      // Write audio data
      const channels = [];
      for (let i = 0; i < numChannels; i++) {
        channels.push(buffer.getChannelData(i));
      }

      let offset = 44;
      for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          let sample = channels[ch][i];
          sample = Math.max(-1, Math.min(1, sample));
          sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          view.setInt16(offset, sample, true);
          offset += 2;
        }
      }

      return arrayBuffer;
    }

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    // Slider event listeners
    [widthSlider, richnessSlider, volumeSlider, qualitySlider].forEach(slider => {
      slider.addEventListener('input', updateSliderDisplays);
    });

    // Preset buttons
    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        applyPreset(btn.dataset.preset);
      });
    });

    // Resize handler for canvas
    window.addEventListener('resize', () => {
      if (originalBuffer) {
        drawWaveform('originalWaveform', originalBuffer);
      }
      if (monoBuffer) {
        drawWaveform('monoWaveform', monoBuffer);
      }
    });
  </script>
</body>
</html>
